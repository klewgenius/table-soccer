'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.__esModule = true;

exports.default = function (_ref5) {
  var props = _objectWithoutProperties(_ref5, []);

  return _react2.default.createElement(_JSONNestedNode2.default, _extends({}, props, {
    getChildNodes: getChildNodes,
    nodeType: 'Iterable',
    nodeTypeIndicator: '()',
    renderItemString: renderItemString
  }));
};

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _JSONNestedNode = require('./JSONNestedNode');

var _JSONNestedNode2 = _interopRequireDefault(_JSONNestedNode);

var _grabNode = require('./grab-node');

var _grabNode2 = _interopRequireDefault(_grabNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// Returns the "n Items" string for this node, generating and caching it if it hasn't been created yet.
function renderItemString(_ref) {
  var data = _ref.data;
  var getItemString = _ref.getItemString;
  var itemString = _ref.itemString;
  var itemType = _ref.itemType;

  if (!itemString) {
    var count = 0;
    if (Number.isSafeInteger(data.size)) {
      count = data.size;
    } else {
      for (var _iterator = data, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref2 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref2 = _i.value;
        }

        var entry = _ref2;
        // eslint-disable-line no-unused-vars
        count += 1;
      }
    }
    itemString = count + ' entr' + (count !== 1 ? 'ies' : 'y');
  }
  return getItemString('Iterable', data, itemType, itemString);
}

// Returns the child nodes for each entry in iterable.
// If we have generated them previously we return from cache; otherwise we create them.
function getChildNodes(_ref3) {
  var data = _ref3.data;
  var getItemString = _ref3.getItemString;
  var labelRenderer = _ref3.labelRenderer;
  var previousData = _ref3.previousData;
  var styles = _ref3.styles;
  var theme = _ref3.theme;
  var valueRenderer = _ref3.valueRenderer;

  var childNodes = [];
  for (var _iterator2 = data, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
    var _ref4;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref4 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref4 = _i2.value;
    }

    var entry = _ref4;

    var key = null;
    var value = null;
    if (Array.isArray(entry)) {
      key = entry[0];
      value = entry[1];
    } else {
      key = childNodes.length;
      value = entry;
    }

    var previousDataValue = undefined;
    if (typeof previousData !== 'undefined' && previousData !== null) {
      previousDataValue = previousData[key];
    }

    var node = (0, _grabNode2.default)({
      getItemString: getItemString,
      key: key,
      labelRenderer: labelRenderer,
      previousData: previousDataValue,
      styles: styles,
      theme: theme,
      value: value,
      valueRenderer: valueRenderer
    });

    if (node !== false) {
      childNodes.push(node);
    }
  }

  return childNodes;
}

// Configures <JSONNestedNode> to render an iterable